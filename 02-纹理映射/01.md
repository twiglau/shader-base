# 纹理映射 - 将一张图片映射到一个集合图形的表面上去  
* 将图像贴到我们绘制的白板上, 就可以称这个在物体表面的图像为 图像纹理 或者 纹理.
* 纹理映射的作用是根据纹理图像在光栅化后的每片元 涂上适当的颜色.
组成纹理图像的像素又称为 纹素. 每个纹素的颜色都可以用 RGB 或者 RGBA 格式编码.
* 纹理坐标: 为了把一张纹理映射到一个物体上, 我们需要指定物体的每个顶点各自对应纹理的哪个部分. 纹理使用上更多的是2D纹理, 纹理坐标也有类似像 x 和 y 的表示法. 通常称之为 uv 坐标. u 对应水平方向, v对应垂直方向. 如果是 3D 纹理第三个方向则是 w.它们的数值范围都在 0~1 之间. 纹理坐标始于 (0, 0)点, 也就是 纹理左下角.  使用纹理坐标来获取 纹理颜色的方法称为 采样.  每个顶点会关联一个纹理坐标, 用来表明 该从纹理的那个部分开始采样. 
* 纹理坐标的设置: 
```
const uvs = [
    0, 0, // 左下角
    0, 1, // 左上角
    1, 0, // 右上角
    1, 1  // 右上角
]
```  
> 映射的原理 主要是将 纹理图像的顶点映射到 WebGL 坐标系统的四个顶点.  
> 如果我们设置纹理坐标的范围超过了 0~1 ? 需要了解 纹理的环绕方式.  
* 纹理的环绕方式:  
> WebGL 的环绕方式, 默认是重复这个纹理.  
> 还有几种选择:  REPEAT (默认环绕), MIRRORED_REPEAT (和REPEAT 的一样, 只不过每次重复的图片是镜像放置的), CLAMP_TO_EDGE (超出的部分会重复纹理坐标的边缘产生一种边缘被拉伸的效果)  
```
// 
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
```
> 以上代码可以对坐标不同轴向设置: `gl.TEXTURE_WRAP_()`
>> 1. 2D纹理 S T 对应的就是 u v.
>> 2. 3D纹理 S T R 对应的就是 u v w.
> 注意: WebGL1 中的 REPEAT 的模式 对纹理图片尺寸有要求,宽度和高度需要为2的整数次幂.

* 纹理过滤方式:  纹理坐标不依赖于分辨率, 可以是任意的浮点值.所以 WebGL 知道如何将纹素映射到纹理坐标. 但是如果此时有一个小的纹理需要映射到一个很大的物体上. 就可能导致多像素都映射到同一个纹素上.  相反单个像素可能会被映射到多个纹素. 纹理过滤就是为了解决不一致时纹理采样计算问题. 有以下方法:  
> 1. NEAREST 临近过滤  -> 会直接选择中心点最接近纹理坐标那个像素. 效率最高, 简单.
> 2. LINEAR  线性过滤  -> 会选择中心点周围最近的 4个纹理像素加权计算出来. 一个纹理像素的中心距离纹理坐标越近,那么这个纹理像素的颜色对最终的样本颜色贡献越大.  可以产生更加真实的输出.  
```
// 当进行缩小时
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
// 当进行放大时
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
```

# 为什么 2D 纹理是个 uniform 但是却不同 gl.uniform 相关的 API 来赋值? 
* 因为在 WebGL 中会给纹理分配一个默认的纹理位置 => 称之为 纹理单元.
* 默认激活的纹理单元是 0, 因此我之前没有执行任何位置值的分配, 纹理贴图会自动绑定到默认的纹理单元上  
* 当然我们也可以通过 gl.uniform 来给片段着色器设置多个纹理, 只需要激活对应的纹理单元即可.  
* 通用设备支持 8 个纹理单元, 现代中高端设备支持会更多. 一般情况下会限制 8个左右, 它们的编号分别是 gl.TEXTURE0 到 gl.TEXTURE8. 通过这种编号方式我们可以在循环纹理单元的时候更方便.  

# 图片上下内容颠倒了?
* 图片自身还有坐标,而图片的坐标一般都遵守的阅读模式, 也就是说, 我们在阅读一篇文章的时候, 通常是从左上角开始阅读, 然后从左往右 x 递增, 从上往下 y 递增. 这个时候, 它和纹理坐标的坐标的原点 就不一致, 所以导致了 上下翻转. 
* 可以采用 WebGL 翻转 y 轴的 API 将图像翻转回来.
