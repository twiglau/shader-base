
# 渲染管线: GPU绘制物体的时候, 标准的,流水线一样的操作; => 3D => 绘制到我们的屏幕上; 一个 PASS

# 游戏引擎如何绘制物体? 
* CPU + 内存, GPU + 显存; 具体绘制物体时由 GPU 来运算, 绘制数据 (CPU->显存), 绘制的控制(CPU -> GPU 下命令 `DrawCall` 开机绘制)
> i: 游戏引擎在给GPU管道渲染流水线 提交绘制数据, 下绘制命令之前, 还要做一件事情:
>> 装载Shader代码, 到我们的GPU, 配置渲染管线; [装载Shader代码到GPU, 配置管线的一些参数]
>> 以上操作名词叫: SetPassCall, 这个操作也是非常消耗性能的
>> 优化的时候, 要尽可能减少 切换Shader, 来减少 SetPassCall.

> a: 美术3D模型 -> 工程文件里面
> b: 游戏引擎(CPU) -> 读取工程文件 -> 内存 -> 拷贝到显存;
> c: 游戏世界: 坐标, CPU还要把坐标,平移, 旋转, 缩放 -> 矩阵 -> CPU;
> d: 架设摄像机: 定义的是一个观察者的数据: 位置,方向(旋转),视角(摄像机的属性, 成像方式(透视, 正交)) 矩阵 -> GPU;
> e: 我们就是要将我们的世界中的物体 -> 转换为 -> 观察者为坐标系下的坐标 -> 从这个角度来将物体提交给 GPU绘制, 我们才能正确的绘制出来我们的世界.
> f: 传递模型数据给我们的 GPU -> 显存里面: 模型: 点->线->面, 纹理数据; 光的一些数据; 等等;
>> 顶点(模型坐标(模型原点), 纹理坐标, 法线向量, 切线向量)

> g: 纹理数据如何生成;
>> a: 雕刻出来一个模型 -> 给这个模型上色;
>> b: 准备一张白纸 -> 包住我们的模型, 每个三角形的顶点的位置, 我们按下图钉; 白纸就贴到了我们的模型: 每个顶点按下一个图钉 => 就是模型了.
>> c: "画笔" -> 涂上颜色 --> 
>> d: 导出一个建好的模型: 模型形状数据导出来 -> 模型颜色数据;把前面一个个图钉拔掉,取下白纸,展开后,就是贴图; 每个顶点洞,对应的顶点的纹理坐标. (0, 0) ~ (1, 1)

> h: 所有数据准备好以后, 我们下一个 DrawCall 命令;

# 管道渲染流水线的流程: 
```
顶点初始化 => [顶点shader] => Tellellation曲面化 => 几何shader
=> 裁剪,投影 => 三角形遍历 => [片元着色shader] => 输出2D图像
``` 
* 顶点初始化: CPU -> 顶点 -> GPU -> 显存里面 得到一个个顶点数据;
* 顶点Shader:
> 形状变换(可选); 通过代码, 改变顶点的模型坐标; => sin 
> 坐标变换(绘制到准确的位置);
>> a: 模型坐标 -> 矩阵 -> 世界坐标 -> 摄像机坐标 -> 投影坐标系(3D -> 平面)
>> 透视投影, 正交投影
> 传递数据; 
>> 数据传回给渲染管线;
>> 怎么传? 有固定盒子, 把什么数据,放什么盒子, 这个是有编程者自己组织管理的;
>> 接受数据: 也是从这些盒子里面接受数据, 固定的数据在哪些盒子, 有一个默认规定的;

* 三角形遍历 - 变成一个个片元, 像素点
> 遍历三角形时, 渲染管线会做一次 `插值` -> 每个片元 '数据' (编程者规定, 你要传递给片元哪些数据, 顶点数据 -> 插值 -> 片元数据)
> 给三角形涂色, 涂色的最小单位: `片元` [是那些数据? 编程者自己定的]
> 通常情况下, 片元数量时远远大于顶点数目的;
> 片元函数计算次数远大于顶点数目的;

* 片元着色Shader:
> 片元-> 纹理坐标 -> 颜色数据 -> 着色到这个片元 -> 再将数据传回的 `渲染管线`;

