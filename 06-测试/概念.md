# 在之前的视频里, 我们知道的都是平面上的渲染, 直接往屏幕上画东西就可以了. 考虑的内容比较单一.但在3D游戏里, 我们需要考量的东西则会很多.
* 比如在人群中视野方向的任务模型很多, 每个任务模型都需要绘制, 如何让距离相机近的物体不被离得远的遮挡? 
* 比如街道两边有很多带有玻璃窗的商店, 如何通过玻璃窗看到链的景象. 

# 要实现以上功能, 就需要涉及到渲染流程的最后一个阶段 alpha 测试和混合.
* 在这个阶段里, GPU 主要功能是 逐片元工作,将套门的颜色以某种形式合并, 得到最终在屏幕上显示的像素颜色. 主要涉及的工作有两个:  
> 对片元进行测试并进行合并, 测试决定了片元最终会不会被显示出来, 在 WebGL里, 主要的测试有: 裁剪测试, 透明度测试, 模板测试 以及 深度测试. 这几个测试都是高度配置的, 其中, 考量到裁剪测试没有模板测试来的更加灵活.
> 以下为整个测试流程:  
```
片元 => 模板测试 => 深度测试 => 混合测试 => 颜色缓冲区
```  

# 模板测试[stencil test]  
* 它的本质是 镂空, 通过这样的板子就可以方便的画出某个特定的形状.  
* 模板测试的核心是持有一个模板缓冲, 每个像素或片段都有一个模板值, 通常每个模板值是 8 位, 它的值范围是 0~255, 也就是可以有 256 种不同的值, 这样就可以通过设置我们想要的模板值来丢弃或保留一个片段. 
* 通常用户在启用一个模板缓冲的时候, 会将整个模板缓冲中的所有片段模板值设置为 0, 从而丢弃所有的片段, 然后在设置特定区域的模板值以及比较函数, GPU 会读取用户设置的模板值, 然后将该值与模板缓冲中该位置的模板值, 按比较函数进行比较. 最终决定是保留还是舍弃该片段, 形成镂空.-> 也就是遮罩效果. 
* 在模板测试中有两个很重要的方法是 `stencilFunc` 和 `stencilOp` , 前者用来控制 stencil 的测试方式, 得出测试结果. 后者根据结果决定要如何处理缓冲中的数据.
* stencilFunc  
```
void stencilFunc(GLenum func, GLint ref, GLuint mask);
```
> 第一个参数 `func` 指定模板测试的 比较函数.
> 第二个参数 `ref` 测试的参考值.
> 第三个参数 `mask` 指定操作掩码.
> 在测试时会先将 ref 与 mask 进行 与运算, 再将 ref 与 模板缓冲中的值进行 与运算. 最后根据 `比较函数` 得出结果.
```  
gl.stencilFunc(gl.GEQUAL, 1, 0xff);
```  
> 其中, mask 采用16进制, 是因为数据在计算机中的标识最终都是以二进制形式存在, 但二进制写起来太长了, 因此可以采用十六进制 或者 八进制 解决. 

* stencilOp   
``` 
void stencilOp(GLenum fail, GLenum zfail, GLenum zpass);
```  
> 第一个是 fail 指定当前模板测试不通过时的行为,
> zfail: 指定当前模板测试通过但深度测试未通过时的行为.
> zpass: 指定当前模板测试通过且深度测试也通过时的行为.

* 在 WebGL 中模板测试默认是处于禁用状态  
``` 
gl.enable(gl.STENCIL_TEST);
gl.clear(gl.COLOR_BUFFER_BIT|gl.STENCIL_BUFFER_BIT);
```   

# 深度测试 (Depth Test)  
* 深度测试是3D游戏不可或缺的环节, 可以帮助实现 3D 渲染上物体的遮挡效果, 如果没有深度测试, 可能会出现前后物体的渲染错乱 或者 闪烁的现象. 
* 深度测试核心跟模板测试类似, 也是持有一个深度缓冲, 深度缓冲就像颜色缓冲一样, 存储了每个片段的深度值. 以 16, 24 或者 32 位 float 的形式存储. 在大多数系统中,默认精度是 24.
* 当开启深度测试时, 会将当前渲染的每一个片段的深度值 与 深度缓冲中的内容进行对比测试, 如果测试通过深度缓冲则会更新 新的深度值. 如果测试失败, 片段则会被丢弃. 深度缓冲是在 片段着色器运行之后, 也是在模板测试之后. 在屏幕空间中运行的. 
* 屏幕空间坐标 与 gl.viewport 设置有关.  WebGL 会直接使用 gl 的内建变量 gl_FragCoord, 从片段着色器直接访问, gl_FragCoord 的 x 和 y 分量分别代表了片段的屏幕空间坐标. 同时, 它也包含了一个 z 分量 - 这个是用来存储真正的深度值. 最终用它来和深度缓冲的内容进行对比. 
* depthFunc 函数, 接收一个参数, 这个参数就是用来设置深度比较函数  
```
const gl = canvas.getContext("webgl", { stencil: true, depth: true});
gl.clear(gl.COLOR_BUFFER_BIT|gl.STENCIL_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
gl.enable(gl.DEPTH_TEST);
```  
* 当深度测试通过之后,会将当前片段的 z 值存入深度缓冲. 当前片段的 z 值是介于 0.1~1.0 之间的值. 从观察者角度看到场景中物体的 z 值, 这个是经过投影矩阵作用后, 又经过标准设备坐标变化, 最终得到的基于 0.0~1.0 之间的值. 

# Cocos Creator 实现的模块是在引擎源码中的 webgl/webgl-device.ts 模块.  
```   
resources->3d->engine->cocos->core->gfx->webgl->webgl-device.ts 模块.
```   
* 编辑器中 `PipelineStates` 属性, 所有关于 模板,深度等测试,都在该属性下.
* 实例: 人物 + 背景 => 3D场景.  
> 在有深度测试情况下, 由于背景后面的片段深度 低于 人物模型, 所以背景部分片段都被剔除掉了. 
> 在关闭深度测试后, 现在模型没有了深度, 那些片段的深度都被背景模型填充. 
> 从表现来看,似乎和深度开启,深度测试函数选择 GREATER 的效果应该是要一样的, 因为默认的深度 比较函数默认为 LESS, 也就是深度值小的可以将深度值写入深度缓冲, 从而提出掉高于这部分深度的片段. 现在选择 GREATER 则是将深度值大的写入深度缓冲, 从而剔除掉 深度值小的片段. 
> 根据以上, 将任务模型的 比较函数 改为 GREATER, 会发现, 无论如何更换角度都无法观察到任务模型,
正常来说, 背景模型因为深度测试函数 使用还是 LESS,  所以会覆盖深度缓冲内容, 但是不至于全部都能覆盖到, 那么覆盖不到的地方应该要写入人物的深度值. 也不至于完全看不到. 这是为什么?
> 这主要是因为我们每帧都会做清除深度缓冲的操作, 清除的深度缓冲区 默认值是 1.0, 表示最大的深度值, 因此人物模型再怎么远都不可能比最大值来的远. 所以就能解释的通为什么我们现在看不到了.
> 而对比之前人物没有开启深度测试的时候, 它是不会因为深度测试失败而导致片段被剔除. 所以还是有部分能看到的, 

* 模板测试 - 示例
> 模板测试 需要两个基础操作: 
>> 一个是设定特定区域的模板值. 然后需要绘制的物体, 只需要选择在特定的模板值上绘制即可. 